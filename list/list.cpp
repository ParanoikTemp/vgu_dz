#include "list.h"
#include "iostream"

Node *setList(int len, int arr[]) {
    if (len == 0) return nullptr;  // на случай пустого массива
    /*
     * как вы могли заметить, я использую тут статический массив. Вообще если надо, вы можете использовать динамический
     * чисто теоретически, если вы уберете квадратные скобки и поставите вместо них звездочку перед arr
     * то особо ничего не изменится. Я выбрал статический массив, так как в main его гораздо проще инициализировать
     * одной строкой всего. А вот с динамическим пришлось бы повозиться. Так как надо было бы все равно делать
     * статический и потом переводить его в динамический. Вообщем нахуй надо.
     */
    Node *head = new Node{arr[0]};  // тут мы делаем указатель на самый первый "ведущий" элемент.
    // тот самый который статичен. Генерируем его с первым элементом из массива.
    Node *node = head;  // через этот указатель мы будем уже работать со списком. Он будет у нас двигатсья по элементам,
    // так что, его не жалко.
    for (int i = 1; i < len; ++i) { // так как первый элемент у нас уже есть, то i = 1, то есть мы начинаем заполнение со второго
        node->next = new Node{arr[i]};  // соответственно в следующий элемент мы вклиниваем указатель на новый элемент списка
        node = node->next;  // после этого перемещаемся в конец списка, а если конкретно, то на следующий элемент, чтобы продолжить добавление с него.
    }

    /*
     * Если хотите, можете повыебываться, и написать цикл в одну строку, вот так:
     * for (int i = 1; i < len; ++i, node = node->next) node->next = new Node{arr[i]};
     */

    return head; // ну и в конце, конечно, возвращаем указатель на первый элемент массива, так как к нему привязан весь список
}

int getListLength(Node* node) {  // простая функция на всякий пожарный
    int length = 0;  // сюда запишем длину
    for (; node != nullptr; node = node->next) ++length;  // просто идем до конца списка, пока он не закончится.
    // на каждом элементе плюсуем единичку к количеству.

    /*
     * Если хотите, можете повыебываться, и написать цикл в одну строку, вот так:
     * for (int length = 0; node != nullptr; node = node->next, ++length);
     */

    return length;
}

void printList(Node* node, char delim) {  // тут тоже все на изичах
    // просто идем по каждому элементу кроме последнего
    for (; node->next != nullptr; node = node->next) {
        std::cout << node->value << delim;  // пишем сам элемент и разделитель
    }
    std::cout << node->value;  // последний элемент отдельно, так как ему не нужен разделитель в конце.
    // если вы не понимаете почему, то сочувствую.
}

Node *getNode(Node* node, int index) {  // просто идем на следующий элемент столько раз, какой элемент нам нужен
    for (int i = 0; i < index; ++i) node = node->next;
    return node;
}

Node *pushBack(Node* head, int value) {
    Node* node = head;
    if (node != nullptr) {  // если же список абсолютно пуст, то тут мы тупо добавляем элемент. Если список изначально непустой, то в возврате результата нет смысла.
        while (node->next != nullptr) node = node->next;  // следуем к последнему элементу
        node->next = new Node{value};  // добавляем новый элемент в конец
    } else head = new Node{value};  // если же список пустой, то возвращается ссылка на единственный новый элемент
    return head;
}

Node *pushFront(Node* head, int value) {
    Node* new_head = new Node{value, head};  // создаем новый элемент, который ведет на первый элемент списка. Всё.
    return new_head;
}

Node *insertNode(Node* head, int index, int value) {  // тут можно было сэкономить время используя уже реализованные функции, но для понятности я не буду так делать
    if (head == nullptr) {  // на случай пустого списка
        head = new Node{value};
        return head;
    }
    if (index == 0) {  // Если нужно поставить элемент на первое место, то делаем как в pushFront
        Node* new_head = new Node{value, head};
        return new_head;
    } else {  // иначе стратегия другая
        Node* node = head;  // создаем элемент который будет перемещаться к новому элементу
        for (int i = 0; i < index - 1; ++i) node = node->next;  // идем до элемента перед индексом куда мы будем добавлять
        // То есть если мы хотим сделать элемент с индексом 2, нам нужно остановиться на втором элементе (индекс 1)
        Node* new_node = new Node{value, node->next};  // создаем новый элемент и подключаем его к следующему элементу
        node->next = new_node;  // подключаем новый элемент к предыдущему,
        return head;  // готово! Новый элемент успешно вклинен в список!
    }
}

Node *removeBack(Node *head) {  // удаляем последний элемент
    if (head == nullptr || head->next == nullptr) return nullptr;  // если элемент всего один, или их вовсе нет, то мы все проебали
    Node* node = head;  // иначе создаем итератор (Я ВСПОМНИЛ КАК ЭТО НАЗЫВАЕТСЯ)
    while (node->next->next != nullptr) node = node->next;  // дальше пиздуем до ПРЕДпоследнего элемента
    delete node->next;  // стираем к хуям последний элемент
    node->next = nullptr;  // подтираем следы, заменяя указатель на удаленный элемент на пустоту
    return head;
}

Node *removeFront(Node *head) {
    if (head == nullptr || head->next == nullptr) return nullptr;  // если элемент всего один, или их вовсе нет, то мы все проебали
    Node* new_head = head->next;  // делаем новый главный элемент из следующегг
    delete head;  // подтираем старый
    return new_head;
}

Node *removeNode(Node *head, int index) {  // аналогично insert node
    if (head == nullptr || head->next == nullptr) return nullptr;
    if (index == 0) {  // Если нужно удалить элемент на первом месте, то делаем как в removeFront
        Node* new_head = head->next;  // делаем новый главный элемент из следующего
        delete head;  // подтираем старый
        return new_head;
    } else {  // иначе стратегия другая
        Node* node = head;  // создаем элемент который будет перемещаться к новому элементу
        for (int i = 0; i < index - 1; ++i) node = node->next;  // идем до элемента перед индексом где мы будем удалять
        // То есть если мы хотим удалить элемент с индексом 2, нам нужно остановиться на втором элементе (индекс 1)
        Node* next_node = node->next->next;  // запоминаем следующий за удаляемым элемент
        delete node->next;  // удаляем лишний элемент
        node->next = next_node;  // соединяем разрыв
        return head;  // готово! Элемент успешно удален!
    }
}

Node *reverseNode(Node *head) {
    if (head == nullptr) return nullptr;
    if (head->next == nullptr) return head;
     // этот код я написал в 3:50 методом проб и ошибок
    // даже я сам не понимаю как он работает, но он работает. Хотя я попробую все же пояснить.
    // однако очевидно будет проще, если вы это себе как нить на листочке начертите
    Node *node = head->next, *node2;  // запоминаем следующий элемент
    head->next = nullptr;  // реверсим в никуда самый первый
    while (node != nullptr) {  // идем до конца и останавливаемся в 200 км от конца списка
        node2 = head;  // двигаем хуйню, которая запоминает предыдущий элемент
        head = node;  // двигаем head в хуйню которая запоминает следующий элемент
        node = node->next;  // двигаем хуйню, которая запоминает следующий элемент, на следующий элемент
        head->next = node2;  // меняем указатель текущего элемента, на предыдущий, который записан в хуйне, котораяч на предыдущем элементе всегда
    }
    return head;  // и вот как то это работает. сам в ахуе ес честно.
}