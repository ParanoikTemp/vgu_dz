/*
 * Список я буду разрабатывать для чисел, так что
 * если вам понадобятся строки, то тупо переделайте под строки лол.
 * А, ну и он тут односвязный, угу
 */

struct Node {
    int value;
    Node *next = nullptr;
};

/*
 * Node - это структура ОДНОГО элемента. То есть список состоит из кучи таких структур, связанных друг с другом
 * Формально это выглядит так: Node -> Node -> Node -> nullptr
 * nullptr - означает, что указатель никуда не ссылается. За счет этого, можно сделать конец списка.
 * Я сделал первое значение числом, а второе уже ссылкой на следующий узел с автоматическим значением nullptr,
 * чтобы при добавлении элемента (например в конец) мы могли указать сразу число. Например:
 * Node *node = new Node{5}; - так мы создали элемент списка со значением 5 ведущим в никуда.
*/

/*
 * Немного про структуру списка. Работает эта красота так. У нас есть переменная head. Она хранит ссылку - указатель на
 * самый первый и ведущий элемент списка. Эту переменную по хорошему менять НЕЛЬЗЯ. Иначе вы проебете первый элемент
 * т.к. список односвязный. Если вам нужно пройтись по списку (это будет показано далее), то вы копируете указатель в
 * какую нибудь переменную и уже играетесь с ним. сам head не трогайте. Однако также и не делайте его const, на случай
 * если вам понадобится добавить элемент в начало списка.
 */

Node* setList(int len, int arr[]);  // функция принимает в себя длину массива и сам массив. В примере он статический. Подробнее в коде функции
int getListLength(Node *node);  // Функция принимает список и возвращает его длину.
void printList(Node *node, char delim=' '); // функция принимает список и выводит его. По умолчанию через пробел,
// но все в ваших руках - второй аргумент меняет разделяющший символ. Если одного символа вам мало,
// юзайте строки. В принципе код от этого сильно жирнее не станет
Node *getNode(Node *node, int index);  // возвращает элемент списка по индексу
Node *pushBack(Node *head, int value);  // добавляет в передаваемый в список, передаваемое число в самый конец. Возвращает ссылку на измененный список
Node *pushFront(Node *head, int value);  // добавляет в передаваемый в список, передаваемое число в самое начало. Возвращает ссылку на измененный список
Node *insertNode(Node *head, int index, int value);  // добавляет элемент в передаваемый список, НА указанное место.
Node *removeBack(Node *head);  // удаляет последний элемент в списке.
Node *removeFront(Node *head);  // удаляет первый элемент в списке.
Node *removeNode(Node *head, int index);  // удаляет элемент в передаваемом списке, НА указанном месте.
Node *reverseNode(Node *head);  // возвращает указатель на новый главный элемент списка. Уже перевернутого.
// вообще была идея сделать функцию на проверку зацикливания списка, но сука 4 часа ночи, идите нахуй, я очень сомневаюсь что такое будет на экзамене
